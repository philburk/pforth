# This Makefile can be used to cross-compile pForth on a Linux host to
# an Atari ST target.  GCC is used as host-compiler and VBCC as
# cross-compiler.

# makefile for pForth
# Portable Forth written in 'C'
# by Phil Burk
# For more info visit http://www.softsynth.com/pforth/
#
# See "help" target below.

# Options include: PF_SUPPORT_FP PF_NO_MALLOC PF_NO_INIT PF_DEBUG
# See "docs/pf_ref.htm" file for more info.

# We are going to use VBCC as cross compiler.  I've installed VBCC
# under /opt/vbcc.  It's configured to generate Motorola 680x0 code.
VBCC := /opt/vbcc
PATH := $(VBCC)/bin:$(PATH)
XCC          = vc # The VBCC compiler

SRCDIR       = ../..
PFORTHDIR    = $(SRCDIR)
CSRCDIR      = $(PFORTHDIR)/csrc
FTHDIR       = $(PFORTHDIR)/fth

PFDICAPP     = pforth
PFORTHDIC    = pforth.dic
PFDICDAT     = pfdicdat.h
PFORTHAPP    = pforth.ttp

# We need to create a 32-bit dictionary
WIDTHOPT= -m32
DEBUGOPTS = -g
FULL_WARNINGS =  \
        --std=c89 \
        -pedantic \
        -Wcast-qual \
        -Wall \
        -Wwrite-strings \
        -Winline  \
        -Wmissing-prototypes \
        -Wmissing-declarations
CCOPTS = $(WIDTHOPT) -x c -O2 $(FULL_WARNINGS) $(EXTRA_CCOPTS) $(DEBUGOPTS)

#IO_SOURCE = pf_io_posix.c
IO_SOURCE = pf_io_stdio.c pf_fileio_stdio.c
#IO_SOURCE = pf_io_win32_console.c

EMBCCOPTS = -DPF_STATIC_DIC

#######################################
PFINCLUDES = pf_all.h pf_cglue.h pf_clib.h pf_core.h pf_float.h \
	pf_guts.h pf_host.h pf_inc1.h pf_io.h pf_mem.h pf_save.h \
	pf_text.h pf_types.h pf_words.h pfcompfp.h \
	pfcompil.h pfdicdat_arm.h pfinnrfp.h pforth.h
PFBASESOURCE = pf_cglue.c pf_clib.c pf_core.c pf_inner.c \
	pf_io.c pf_io_none.c pf_main.c pf_mem.c pf_save.c \
	pf_text.c pf_words.c pfcompil.c pfcustom.c
PFSOURCE = $(PFBASESOURCE) $(IO_SOURCE)

VPATH = .:$(CSRCDIR):$(CSRCDIR)/posix:$(CSRCDIR)/stdio


CPPFLAGS = -I. -DPF_BIG_ENDIAN_DIC -DPF_SUPPORT_FP
CFLAGS = $(CCOPTS)
LDFLAGS = $(WIDTHOPT) -lm

COMPILE = $(CC) $(CFLAGS) $(CPPFLAGS)

# Cross compiler flags (for VBCC not gcc)
XCFLAGS = +tos -c99 -O3
#XCPPFLAGS = -DPF_SUPPORT_FP -DWIN32
XCPPFLAGS = -I. -DATARI -DPF_SUPPORT_FP
XLDFLAGS = +tos -lm -lm881

XCOMPILE = $(XCC) $(XCFLAGS) $(XCPPFLAGS)
XLINK = $(XCC) $(XLDFLAGS)

.SUFFIXES: .c .o .eo

PFOBJS     = $(PFSOURCE:.c=.o)
PFEMBOBJS  = $(PFSOURCE:.c=.eo)

.c.o: $(PFINCLUDES)
	$(COMPILE) -c -o $@ $<

.c.eo: $(PFINCLUDES) pfdicdat.h
	$(XCOMPILE) $(EMBCCOPTS) -c -o $@ $<

.PHONY: all clean test
.PHONY: help pffiles pfdicapp pfdicdat pforthapp

all: $(PFORTHAPP)

pffiles:
	@echo "INCLUDE FILES -----------------"
	@echo ${PFINCLUDES}
	@echo "'C' FILES ---------------------"
	@echo ${PFSOURCE}
	@echo "OBJECT FILES ------------------"
	@echo ${PFOBJS}
	@echo "EMBEDDED OBJECT FILES ------------------"
	@echo ${PFEMBOBJS}

# Build pforth by compiling 'C' source.
$(PFDICAPP): $(PFINCLUDES) $(PFOBJS)
	$(CC) -o $@ $(PFOBJS) $(LDADD) $(LDFLAGS)

# Build basic dictionary image by running newly built pforth and including "system.fth".
$(PFORTHDIC): $(PFDICAPP)
	wd=$$(pwd); (cd $(FTHDIR); $${wd}/$(PFDICAPP) -i system.fth)
	(cd $(FTHDIR); cat pforth.dic; rm -f pforth.dic) > $@

$(PFDICDAT): $(PFORTHDIC) $(PFDICAPP)
	echo 'include $(FTHDIR)/savedicd.fth SDAD'>load-dict-tmp.fth&& ./$(PFDICAPP) -d $(PFORTHDIC) load-dict-tmp.fth; rm -f load-dict-tmp.fth

$(PFORTHAPP): $(PFDICDAT) $(PFEMBOBJS)
	$(XLINK) -o $@ $(PFEMBOBJS) $(XLDADD)
	@echo ""
	@echo "Standalone pForth executable written to $(PFORTHAPP)"


# target aliases
pfdicapp: $(PFDICAPP)

pfdicdat: $(PFDICDAT)

pforthapp: $(PFORTHAPP)

help:
	@echo "Use 'make all' to build standalone pForth executable."
	@echo "PForth can be built in several stages using these targets:"
	@echo "   pfdicapp = executable pForth with minimal dictionary. All from 'C'."
	@echo "   pfdicdat = image of full dictionary build by compiling Forth code."
	@echo "   pforthapp = executable with embedded dictionary image. DEFAULT 'all' target."
	@echo ""
	@echo "   The file 'fth/pfdicdat.h' is generated by pForth. It contains a binary image of the Forth dictionary."
	@echo "   It allows pForth to work as a standalone image that does not need to load a dictionary file."

test: $(PFORTHAPP)
	wd=$$(pwd); (cd $(FTHDIR); $(WINE) $${wd}/$(PFORTHAPP) -q t_corex.fth)
	wd=$$(pwd); (cd $(FTHDIR); $(WINE) $${wd}/$(PFORTHAPP) -q t_strings.fth)
	wd=$$(pwd); (cd $(FTHDIR); $(WINE) $${wd}/$(PFORTHAPP) -q t_locals.fth)
	wd=$$(pwd); (cd $(FTHDIR); $(WINE) $${wd}/$(PFORTHAPP) -q t_alloc.fth)
	wd=$$(pwd); (cd $(FTHDIR); $(WINE) $${wd}/$(PFORTHAPP) -q t_floats.fth)

clean:
	rm -f $(PFOBJS) $(PFEMBOBJS)
	rm -f $(PFORTHAPP)
	rm -f $(PFDICDAT) $(FTHDIR)/$(PFDICDAT)
	rm -f $(PFORTHDIC) $(FTHDIR)/$(PFORTHDIC)
	rm -f $(PFDICAPP)
